<!DOCTYPE html>
<html>
  <head>
    <title>Modern JavaScript</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Droid Serif';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">
# Brief history of JavaScript

- Created in 10 days in 1995
- Shipped with NetScape Navigator, became scripting language of the web
- Standardized in 1997 as ECMAScript ("European Computer Manufacturer's Association")
- Called ECMAScript to avoid trademark issues
- Browser implementations are generally called JavaScript
- No new language standards from ECMAScript 3 in 1999 to 2009
- ECMAScript 4 edition was abandoned due to disputes
- ECMAScript 5 released in 2009, 5.1 in 2011
- ECMAScript 6 released in 2015, called ES2015
- ECMAScript 7 released in 2016, called ES2016
- ES.Next refers to ongoing standardization efforts
- Most of the features discussed today are part of ES2015
- Browser support is variable

--- 

# WhatWG

---

# Array.map

Standard: ES5.1

Loop over an array and create a new one

```javascript
var names = ["james", "amy", "mike"];
var capitalizedNames = [];

for(var i = 0; i !== names.length; i++) {
  capitalizedNames.push(names[i].toUpperCase());
}

console.log(capitalizedNames);
// ["JAMES", "AMY", "MIKE"]

```

---

# Array.map 2

becomes

```javascript
var names = ["james", "amy", "mike"];
var capitalizedNames = names.map(function(name) {
  return name.toUpperCase();
})

console.log(capitalizedNames);
// ["JAMES", "AMY", "MIKE"]
```

---

# Array.filter

Create a new array of elements that meet certain criteria

```javascript
var people = [
  {name: "Amy", age: 28 },
  {name: "Mike", age: 14 }
];

var adults = people.filter(function(person) {
  return person.age >= 18;
});

console.log(adults);
// [{ name: "Amy", age: 28 }]
```

---

# Array.reduce

Reduces an array to a single value

```javascript
function sum(numbers) {
  return numbers.reduce(function(a, b) { return a + b; });
}

console.log(sum([2,3,4]));
// 9
```

---

# var/globals to const/let 

Standard: ES2015

- var is execution-scoped (all vars are accessible from the top-level of a function)
- all global vars are part of an object ("window" in a browser environment)

```javascript
var myGlobal = true;
console.log(window.myGlobal); // true

function myFunction() {
  for(var i = 0; i !== 5; i++) {
    if(i === 3) {
      var text = "Hello, world";
    }
  }

  console.log(i, text); // 5, "Hello world"
}

myFunction();
```

???

notes

---

# var/globals to const/let 2

- let is lexically scoped

```javascript
for(let i = 0; i !== 5; i++) {
  if(i === 3) {
    let text = "Hello, world";
  }
}

// ReferenceError: i is not available outside of for loop
console.log(i); 
// ReferenceError: text is not available outside of if statement
console.log(text);
```

---

# var/globals to const/let 3

- const follows the same rules as let, but is immutable (cannot be re-assigned)

```javascript
const myVariable = true;

// TypeError: Assignment to constant variable
myVariable = false; 
```

---

# var/globals to const/let 4

- note that const only creates immutable references, not data structures

```javascript
// Valid code 
const myArray = [1,2,3];
myArray.push(4);

// Valid code
const myObject = {name: "Jim"};
myObject.name = "Fred";
```

---

# Const/let best practices

- Use const if reference is not reassigned
- Use let otherwise

---

# Classes

Standard: ES2015

```javascript
class Shape {
  constructor(name) {
    this.name = name;
  }
}

const shape = new Shape("circle");
```

---

# Classes 2

Classes can be extended

```javascript
class Circle extends Shape {
  constructor(radius) {
    super("circle");
    this.radius = radius;
  }
}
```

# Classes 3

Classes have getters and setters

---

# Common containers

Standard: ES2015

- TypedArray (performant, immutable arrays of ints/floats)
```javascript
var array = new Uint8Array([255, 255, 255]);
```

Used in WebGL code, useful when dealing with binary data

- Map

Somewhat redundant with object

- Set (unique values of any type)
```javascript
const mySet = new Set(['horse', 'dog']);
console.log(mySet.has('horse')); // true
console.log(mySet.has('cat')); // false
```

---

# for/of loops

```javascript
var array = ["James", "Amy", "Mike"];

for(var i = 0; i !== array.length; i++) {
  console.log(array[i]);
}
```

becomes

```javascript
const array = ["James", "Amy", "Mike"];

for(let name of array) {
  console.log(name);
}
```

---

# for/of loops 2

- It can be used to easily iterate over the new data structures, function arguments, generators,
  DOM elements

```javascript
function printAll() {
  var args = [].slice.call(arguments);
  for(var i = 0; i !== args.length; i++) {
    console.log(args[i]);
  }
}
```

becomes

```javascript
function printAll() {
  for(let arg of arguments) {
    console.log(arg);
  }
}

printAll(1,2,3);
// 1
// 2
// 3
```

- for/of is extensible: You can create your own iterable objects &amp; classes

---

# Arrow functions

Shorter than writing functions

```javascript
[1,2,3].reduce(function(a, b) {
  return a + b;
});
```

```javascript

// No braces needed if returning an expression
[1,2,3].reduce((a,b) => a + b);

// You can use return as well if you need to do something more complex
[1,2,3].reduce((a, b) => {
  return a + b;
})

// If there is exactly one parameter, no parentheses are required
["james", "mike", "amy"].map(n => n.toUpperCase());

```

---

# Arrow functions 2

Arrow functions have different binding rules.

```javascript
// Repeats message every second
this.message = "Hello";

setInterval(function() {
  // Because `this` will be changed when this function is executed, 
  // this will print "undefined" repeatedly
  console.log(this.message);
}, 1000)
```

---

# Arrow functions 3

Old solution

```javascript
this.message = "message";

var self = this;
setInterval(function() {
  // Create a closure with a variable referencing the object we want to use
  console.log(self.message);
}, 1000)
```

---

# Arrow functions 4

Arrow functions inherit `this` and `arguments` from the context they are written in

```javascript
this.message = "message";

setInterval(() => {
  // No additional code required to reference 'this'
  console.log(this.message);
}, 1000);
```

Very handy when working with classes, e.g. React components

---

# Template literals 1

lots of javascript code uses string concatenation

```javascript
let person = {
  name: "James",
  age: 24
};

console.log("Name: '" + person.name + "', age: " + person.age); 
// Name: 'James', age: 24
```

---

# Template literals 2

template literals make code much cleaner

```javascript
let person = {
  name: "James",
  age: 24
}

console.log(`Name: '${person.name}', age: ${person.age}`);
```

---

# Template literals 3

You can write custom template literals that turn strings into any kind of value you want.

For example, a CSS color parser that breaks down a string like '#ff0000' into an array like [255, 0, 0]

```javascript
function color(strings) {
  const string = strings[0];
  return [
    parseInt(string.slice(1, 3), 16),
    parseInt(string.slice(3, 5), 16),
    parseInt(string.slice(5, 7), 16)
  ];
}

const red = color`#ff0000`;
console.log(red); // [255, 0, 0]
```

---

# Template literals 4

These can become quite elaborate

For example: hyperx is a library that allows you to build HTML from a string


```javascript
function click() {
  alert("Button was clicked");
}

var button = hx`<button onclick=${click}>Click me!</button>`
console.log(button); // <button></button>
```

---

# Object property shorthand

```javascript
var name = "James", age = 24, occupation = "Electrician";

var person = {
  name: name,
  age: age,
  occupation: occupation
}
```

### becomes

```javascript
let name = "James", age = 24, occupation = "Electrician";

// Variable names without a colon are automatically used as property names
let person = {name, age, occupation};
```

---

# Destructuring bind

``` javascript
var color = [255, 0, 0];
var red = color[0];
var green = color[1];
var blue = color[2];
```

### becomes

```javascript
const color = [255, 0, 0];
const [red, green, blue] = color;
```

---

# Destructuring bind 2

also works on objects

```javascript
var person = {
  name: "James",
  age: 24, 
  occupation: "Electrician"
}

var name = person.name;
var age = person.age;
var occupation = person.occupation;
```

### becomes

```javascript
const person = {
  name: "James",
  age: 24,
  occupation: "Electrician"
};

const {name, age, occupation} = person;
```

---

# Destructuring bind 3

Can be nested arbitrarily

```javascript
const person = {
  name: "James", 
  age: 24,
  occupations: ["Electrician", "Plumber"]
};

const {name, age, occupations: [occupation1, occupation2]} = person;

console.log(name, age, occupation1, occupation2);
// James 24 Electrician Plumber
```

---

# Destructuring bind 4

Can even be used in function parameters

```javascript
function printPerson({name, age}) {
  console.log(name, age);
}

printPerson({name: "James", age: 24});
// James 24 
```

---

# Computed property names

Standard: ES2015

```javascript

var field = "spouse";

var person = {
  name: "James",
  age: 24
}

person[field] = "Mary";
```

## becomes

```javascript
const field = "spouse";
const person = {
  name: "James",
  age: 24,
  [field]: "Mary"
}
```

---

# Computed object properties 2

Computed object properties can be any valid expression

```javascript
const occupationAndSalary = ["Electrician", 50000]

const person = {
  name: "James",
  age: 24,
  [`salaryAs${occupationAndSalary[0]}`]: occupationAndSalary[1],
}

console.log(person["salaryAsElectrician"]); // 50000
```

---

# Object.assign

Standard: ES2015

Copying and merging objects

```javascript
var person = { name: "James", age: 24 };
var person2 = {};
person2.name = person2;
person2.age = 24;
```

Or with jQuery

```javascript
var person = { name: "James", age: 24 };
var person2 = $.extend({}, person)
```

```javascript
var person = { name: "James", age: 24 };
var person2 = Object.assign({}, person);
```

---

# Object.assign 2

Can be used to merge multiple objects

```javascript
var person = { name: "James", age: 24 };
var spouse = { name: "Mary", age: 25 };

Object.assign(person, {spouse: spouse});
console.log(person);
// { name: "James", age: 24, spouse: { name: "Mary", age: 25 }}

```

---

# Selectors API



---

# Spread operator

So cutting edge, it's not even part of a standard yet

Can be used in function arguments

```javascript
function sum() {
  var numbers = [].slice.call(arguments);
  
  return numbers.reduce(function(a, b) { return a + b });
}

sum(2,3,4); // 2 + 3 + 4 => 9
```

becomes

```javascript
function sum(...numbers) {
  return numbers.reduce((a, b) => a + b);
}
```

---

# Modules

#### globals

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
```

#### commonJS 

```javascript
var $ = require("jquery");
var bootstrap = require("bootstrap");
```

#### es2015 modules

```javascript
import $ from 'jquery';
import bootstrap from 'bootstrap';
```

---

# Modules 2

ES2015 modules are static, and imports cannot be changed at runtime.

```javascript
import $ from 'jquery';

$ = somethingElse; // error!
```

This allows an intelligent compiler to eliminate dead code.

---

# Modules 3 

You can import specific fields of a module and rename them as you please, using a syntax similar
to the object propertyshorthand

```javascript
import { get as GET, post as POST } from 'jquery';

GET('/myData');
```

---

# JSX

- mix HTML or other XML-like formats with JavaScript code
- not a proposed part of any standard
- used by react, react native, and other web frameworks

```
const message = "Hello world";
const element = <div>
  <p style={{color: 'green'}}>{message}</p>
</div>
```

transpiles down to

```javascript
var message = "Hello world";
var element = React.createElement(
  "div",
  null,
  React.createElement(
    "p",
    { style: { color: 'green' } },
    message
  )
);
```

---

# Problem

- Not all browsers support all of these features
- Most consumer browsers are aggressively upgraded
- Some users may be on old browsers

---

# Solution: transpilation

- Support new language features by compiling new down to older standards
- However, generally doesn't handle runtime functionality such as Object.assign, document.querySelector, etc

---

# Solution: polyfills

- A small bit of code that checks whether a feature is supported in a browser
- If not, will load more code and extend the environment with new functionality

---

# Babel

- from Facebook

- very extensible, supports multiple standards as well as plugins to add new features such as JSX
and spread operator

```javascript
const name = "James";
const age = 24;

const person = {name, age};

console.log(`Name: ${person.name}, age: ${person.age}`);
```

compiles down to

```javascript
var name = "James";
var age = 24;

var person = { name: name, age: age };

console.log("Name: " + person.name + ", age: " + person.age);
```

---

# Webpack


---


    </textarea>
    <script src="/remark-latest.min.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        var slideshow = remark.create();
      });
    </script>
  </body>
</html>