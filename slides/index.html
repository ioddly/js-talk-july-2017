<!DOCTYPE html>
<html>
  <head>
    <title>Modern JavaScript</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Droid Serif';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">
## Intro to ES2015 & React

---

## Brief history of JavaScript

- Created in 10 days in 1995
- Shipped with NetScape Navigator, became scripting language of the web
- Standardized in 1997 as ECMAScript ("European Computer Manufacturer's Association")
- Called ECMAScript to avoid trademark issues
- Browser implementations are generally called JavaScript
- No new language standards from ECMAScript 3 in 1999 to 2009
- ECMAScript 4 edition was abandoned due to disputes
- ECMAScript 5 released in 2009, 5.1 in 2011
- ECMAScript 6 released in 2015, called ES2015
- ECMAScript 7 released in 2016, called ES2016
- ECMAScript 8 released in June 2017, called ES2017
- ES.Next always refers to ongoing standardization efforts
- Most of the features discussed today are part of ES2015

---

## HTML Standard

- HTML4 in 2000
- HTML5 finalized in 2014
- Worked on by WhatWG (Web Hypertext Application Technology Working Group)
- and W3C (World Wide Web Consortium)
- WhatWG publishes a "Living Standard" which is subject to incremental changes
- Some APIs today are part of HTML5, some are part of the Living Standard

---

## Browser support

- Standards and browers are moving much more quickly now
- Most consumer browsers are aggressively upgraded 
- For example, 25% of web users as of June 2017 are on Chrome 58, released in April 2017
- However, some users are on older browsers
- We will discuss strategies to maintain compatibility with older browsers

---

#### var/globals to const/let 

Standard: ES2015

- var is execution-scoped (all vars are accessible from the top-level of a function)
- all global vars are part of an object ("window" in a browser environment)

```javascript
var myGlobal = true;
console.log(window.myGlobal); // true

function myFunction() {
  for(var i = 0; i !== 5; i++) {
    if(i === 3) {
      var text = "Hello, world";
    }
  }

  console.log(i, text); // 5, "Hello world"
}

myFunction();
```

???

notes

---

# var/globals to const/let 2

- let is block scoped

```javascript

let test = true;
console.log(window.test); // undefined

for(let i = 0; i !== 5; i++) {
  if(i === 3) {
    let text = "Hello, world";
  }
}

// ReferenceError: i is not available outside of for loop
console.log(i); 
// ReferenceError: text is not available outside of if statement
console.log(text);
```

---

#### var/globals to const/let 3

- const follows the same rules as let, but is immutable (cannot be re-assigned)

```javascript
const myVariable = true;

// TypeError: Assignment to constant variable
myVariable = false; 
```

---

#### var/globals to const/let 4

- note that const only creates immutable references, not data structures

```javascript
// Valid code 
const myArray = [1,2,3];
myArray.push(4);

// Valid code
const myObject = {name: "Jim"};
myObject.name = "Fred";
```

---

#### Classes
Standard: ES2015

```javascript
class Animal {
  constructor(species, sound) {
    this.species = species;
    this.sound = sound;
  }

  speak() {
    console.log(this.species, 'says', this.sound);
  }
}

const dog = new Animal("dog", "woof!");
dog.speak(); // dog says woof
```

---

#### Classes 2: inheritance 

```javascript
class Dog extends Animal {
  constructor(name, breed) {
    super("dog", "woof!");
    this.name = name;
    this.breed = breed;
  }
}

const dog = new Dog('Spot', 'Dalmatian');
```

---

#### Classes 3: Getters, setters

```javascript
class Account {
  constructor(assets, debt) { 
    this.assets = assets;
    this.debt = debt;
  }

  get netWorth() {
    return this.assets - this.debt;
  }
  
  set netWorth(value) {
    if(value > 0) {
      this.assets = value;
      this.debt = 0;
    } else {
      this.assets = 0;
      this.debt = value;
    }
  }
}
```

---

#### Classes 4: Static methods

```javascript
class Account {
  constructor(assets, debt) {
    this.assets = assets;
    this.debt = debt;
  }

  static makeNewAccount() {
    return new Account(0, 0);
  }
}

Account.makeNewAccount();
```

---

#### for/of loops

Standard: ES2015

```javascript
var array = ["James", "Amy", "Mike"];

for(var i = 0; i !== array.length; i++) {
  console.log(array[i]);
}
```

becomes

```javascript
const array = ["James", "Amy", "Mike"];

for(let name of array) {
  console.log(name);
}
```

---

#### for/of loops 2

- Can be used to easily iterate over things other than arrays, such as function arguments

```javascript
function printAll() {
  var args = [].slice.call(arguments);
  for(var i = 0; i !== args.length; i++) {
    console.log(args[i]);
  }
}
```

becomes

```javascript
function printAll() {
  for(let arg of arguments) {
    console.log(arg);
  }
}

printAll(1,2,3);
// 1
// 2
// 3
```

- for/of is extensible: You can create your own iterable objects &amp; classes

---

#### Generators

Standard: ES2015

Generators are functions which *yield* multiple values by pausing in their execution.

---

#### Generators 2

```javascript
function* generator() {
  yield 1;
  yield 2;
  yield 3;
}

var g = generator();
console.log(g.next().value); // 1
console.log(g.next().value); // 2
console.log(g.next().value); // 3
```

---

#### Generators 3

Generators often yield the result of loops

For example, an even number generator

``` javascript
function* evens(n) {
  for(let i = 0; i <= n; i += 2) {
    yield i;
  }
}

var g = evens(6); // Generate even numbers up to 6
console.log(g.next().value); // 0
console.log(g.next().value); // 2
console.log(g.next().value); // 4
console.log(g.next().value); // 6
```

---

#### for/of loops 3: custom generator

```javascript
function* evens(n) {
  for(let i = 0; i <= n; i += 2) {
    yield i;
  }
}

for(let i of evens(10)) {
  console.log(i);
}
// 0 2 4 6 8 10
```

---

#### Arrow functions

Shorter than writing functions

```javascript
function add(a, b) {
  return a + b;
}
```

```javascript
// No braces or return needed if returning an expression
const add = (a, b) => a + b;

// You can use braces + return as well if you need to do something more complex
const add = (a, b) => {
  return a + b;
}

// No parentheses needed for single-argument functions
const add2 = a => a + 2
```

---

#### Arrow functions 2

Arrow functions inherit `this` and `arguments` from the context they are written in.

```javascript
this.message = "message";

var self = this;
setInterval(function() {
  // To reference this.message, we have to save off 'this' as a separate variable
  // Because this will have changed inside of this callback function
  console.log(self.message);
}, 1000)
```

```javascript
this.message = "message";

setInterval(() => {
  // No additional code required to reference 'this'
  console.log(this.message);
}, 1000);
```

Very handy when working with classes, e.g. React components

---

#### Default function arguments

```javascript
function raiseToPower(number, exponent = 2) {
  return Math.pow(number, exponent);
}

console.log(raiseToPower(4)); // 4^2 = 16
console.log(raiseToPower(4, 3)); // 4^3 = 64
```

---

#### Template literals 1

lots of javascript code uses string concatenation

```javascript
let person = {
  name: "James",
  age: 24
};

console.log("Name: '" + person.name + "', age: " + person.age); 
// Name: 'James', age: 24
```

---

#### Template literals 2

Uses backticks

```javascript
let person = {
  name: "James",
  age: 24
}

console.log(`Name: '${person.name}', age: ${person.age}`);
// Name: 'James', age: 24
```

---

#### Object property shorthand

```javascript
var name = "James", age = 24, occupation = "Electrician";

var person = {
  name: name,
  age: age,
  occupation: occupation
}
```

#### becomes

```javascript
let name = "James", age = 24, occupation = "Electrician";

// Variable names without a colon are automatically used as property names
let person = {name, age, occupation};
```

---

#### Object property shorthand 2

Methods

```javascript

let person = {
  name: "James",
  age: 24,
  toString() {
    return `Name: ${this.name}, age: ${this.age}`;
  }
}

console.log(person.toString()); // Name: James, age: 24
```

---

#### Destructuring bind

``` javascript
var color = [255, 0, 0];
var red = color[0];
var green = color[1];
var blue = color[2];
```

#### becomes

```javascript
const color = [255, 0, 0];
const [red, green, blue] = color;
```

---

#### Destructuring bind 2

also works on objects

```javascript
var person = {
  name: "James",
  age: 24, 
  occupation: "Electrician"
}

var name = person.name;
var age = person.age;
var occupation = person.occupation;
```

#### becomes

```javascript
const person = {
  name: "James",
  age: 24,
  occupation: "Electrician"
};

const {name, age, occupation} = person;
```

---

#### Destructuring bind 3

Can be nested arbitrarily

```javascript
const person = {
  name: "James", 
  age: 24,
  occupations: ["Electrician", "Plumber"]
};

const {name, age, occupations: [occupation1, occupation2]} = person;

console.log(name, age, occupation1, occupation2);
// James 24 Electrician Plumber
```

---

#### Destructuring bind 4

Can even be used in function parameters

```javascript
function printPerson({name, age}) {
  console.log(name, age);
}

var person = { name: "James", age: 24 };
printPerson(person);
// James 24 
```

---

#### Object.assign

Standard: ES2015

Copy and merge objects

```javascript
var person = { name: "James", age: 24}

Object.assign(person, { age: 25 });
```

Compare jQuery

```javascript
var person = { name: "James ", age: 24}

$.extend(person, { age: 25 })
```

---

#### Object.assign 2

Also handy for copying objects by passing a new object as the first argument

```javascript
var person = { name: "James", age: 24 };

var person2 = Object.assign({}, person);

person2.name = "Nathan";

console.log(person); // { name: "James", age: 24 }
console.log(person2); // { name: "Nathan", age: 24 }
```

---

#### Rest parameters

Standard: ES2015

Rest parameters put extra arguments to a function in a real Array

```javascript
function sum() {
  var numbers = [].slice.call(arguments);
  
  return numbers.reduce(function(a, b) { return a + b });
}

sum(2,3,4); // 2 + 3 + 4 => 9
```

becomes

```javascript
function sum(...numbers) {
  return numbers.reduce((a, b) => a + b);
}
```

---

#### Spread operator

Can also be used in reverse, to apply a function against multiple parameters

```javascript
console.log(...[1, 2, 3])

// equivalent to console.log(1, 2, 3);
```

And combined with destructuring bind

```javascript
const [first, ...rest] = [1, 2, 3, 4, 5];

console.log(first, rest); // 1, [2, 3, 4, 5]

```

---

#### Spread operator 2: property spread

Not in any standard yet, just a proposal

Can be used to copy and modify objects

```javascript
var person = {name: "James", age: 24}
var person2 = {...person, age: 25}
// Equivalent to Object.assign({}, person, { age: 25 });
```

Really helps with Redux.

---

#### Promises 1

Doing things asynchronously in JavaScript often results in "callback hell"

```javascript
step1(function (value1) {
    step2(value1, function(value2) {
      step3(value2, function(value3) {
        // Do something with value3
      });
    });
});
```

---

#### Promises 2

Standard: ES2015

```javascript
step1()
  .then(value1 => step2(value1))
  .then(value2 => step3(value2))
  .done(value3 => {
    // Do something with value3
  }).catch(() => {
    // Catch errors at any point during this.
  });
```

---

#### Async/await

Standard: ES2017

```javascript
async function myFunction() {
  const value1 = await step1();
  const value2 = await step2(value1);
  const value3 = await step3(value2);
  return value3;
}
// returns a promise
```


---

##### Modules

#### globals

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>

<script type="text/javascript">
$(document).ready(function() {
  console.log('hello world');
});
</script>
```

---

#### commonjs

```javascript
var $ = require("jquery");
var bootstrap = require("bootstrap");

module.exports = {
  myFunction: function() {},
  myVariable: true,
  // ....
}
```
---

#### es2015 modules

```javascript
import $ from 'jquery';
import bootstrap from 'bootstrap';

export function myFunction() {

}

export const myVariable = true;
```

---

#### es2015 modules 2

ES2015 modules are static, and imports cannot be changed at runtime.

```javascript
import $ from 'jquery';

$ = somethingElse; // error!
```

This allows an intelligent bundler to eliminate dead code. ("tree-shaking")

#### window.fetch

XMLHTTPRequest, pretty verbose

```javascript
var req = new XMLHttpRequest();
req.addEventListener("load", onLoad);
req.open('GET', 'https://example.com/example.json');
req.send();
```

Or jQuery

```javascript
$.get('https://example.com/example.json', function(response) {

});
```

---

#### window.fetch 2

Standard: WHATWG Living Standard

Built into browser, based on Promises

```javascript
window.fetch('https://example.com/example.json')
  .then(response => response.json())
  .then(result => {

  });
```

---

#### JSX

- mix HTML or other XML-like formats with JavaScript code
- not a proposed part of any standard
- used by react, react native, and other web frameworks

```javascript
const element = <p>Hello world</p>
```

transpiles down to

```javascript
const element = React.createElement('p', null, 'Hello world');
```

---

#### Problem

Browser support is highly variable

---

#### Solution: transpilation

- Transpilation = transforming source code to source code
- Support new language features by compiling new down to older standards
- However, transpilation generally doesn't handle runtime functionality such as Object.assign, document.querySelector, etc

---

#### Solution: polyfills

- A small bit of code that checks whether a feature is supported in a browser
- If not, will load more code and extend the environment with new functionality

---

#### Babel

- transpiler from Facebook

- very extensible, supports multiple standards as well as plugins to add new features such as JSX
and spread operator

```javascript
const name = "James";
const age = 24;

const person = {name, age};

console.log(`Name: ${person.name}, age: ${person.age}`);
```

compiles down to

```javascript
var name = "James";
var age = 24;

var person = { name: name, age: age };

console.log("Name: " + person.name + ", age: " + person.age);
```

---

#### Webpack

- Handles running various preprocessors, bundling and compressing resulting code and static
resources
- Not required for compatibility, but useful to handle a complex build process
- In combination with ES2015 modules, can remove unused code

???

stop here for livecoding

---

#### Thanks for putting up with me.

[upvalue.io]

---
    </textarea>
    <script src="remark-latest.min.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        var slideshow = remark.create();
      });
    </script>
  </body>
</html>
