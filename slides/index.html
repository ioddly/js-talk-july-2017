<!DOCTYPE html>
<html>
  <head>
    <title>Modern JavaScript</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Droid Serif';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">
# Modern JavaScript Development

---

# Brief history of JavaScript

- Created in 10 days in 1995
- Shipped with NetScape Navigator, became scripting language of the web
- Standardized in 1997 as ECMAScript ("European Computer Manufacturer's Association")
- Called ECMAScript to avoid trademark issues
- Browser implementations are generally called JavaScript
- No new language standards from ECMAScript 3 in 1999 to 2009
- ECMAScript 4 edition was abandoned due to disputes
- ECMAScript 5 released in 2009, 5.1 in 2011
- ECMAScript 6 released in 2015, called ES2015
- ECMAScript 7 released in 2016, called ES2016
- ECMAScript 8 released in June 2017, called ES2017
- ES.Next always refers to ongoing standardization efforts
- Most of the features discussed today are part of ES2015

---

# HTML Standard

- HTML4 in 2000
- HTML5 finalized in 2014
- Worked on by WhatWG (Web Hypertext Application Technology Working Group)
- and W3C (World Wide Web Consortium)
- WhatWG publishes a "Living Standard" which is subject to incremental changes
- Some APIs today are part of HTML5, some are part of the Living Standard

---

# Browser support

- Standards and browers are moving much more quickly now
- Most consumer browsers are aggressively upgraded 
- For example, 25% of web users as of June 2017 are on Chrome 58, released in April 2017
- However, some users are on older browsers
- We will discuss strategies to maintain compatibility with older browsers

---

# var/globals to const/let 

Standard: ES2015

- var is execution-scoped (all vars are accessible from the top-level of a function)
- all global vars are part of an object ("window" in a browser environment)

```javascript
var myGlobal = true;
console.log(window.myGlobal); // true

function myFunction() {
  for(var i = 0; i !== 5; i++) {
    if(i === 3) {
      var text = "Hello, world";
    }
  }

  console.log(i, text); // 5, "Hello world"
}

myFunction();
```

???

notes

---

# var/globals to const/let 2

- let is lexically scoped

```javascript

let test = true;
console.log(window.test); // undefined

for(let i = 0; i !== 5; i++) {
  if(i === 3) {
    let text = "Hello, world";
  }
}

// ReferenceError: i is not available outside of for loop
console.log(i); 
// ReferenceError: text is not available outside of if statement
console.log(text);
```

---

# var/globals to const/let 3

- const follows the same rules as let, but is immutable (cannot be re-assigned)

```javascript
const myVariable = true;

// TypeError: Assignment to constant variable
myVariable = false; 
```

---

# var/globals to const/let 4

- note that const only creates immutable references, not data structures

```javascript
// Valid code 
const myArray = [1,2,3];
myArray.push(4);

// Valid code
const myObject = {name: "Jim"};
myObject.name = "Fred";
```

---

# Const/let best practices

- Avoid using var/globals
- Use const if reference is not reassigned
- Use let otherwise

---

# Classes
Standard: ES2015

```javascript
class Animal {
  constructor(species, sound) {
    this.species = species;
    this.sound = sound;
  }

  speak() {
    console.log(`the ${this.species} says ${this.sound}`);
  }
}

const dog = new Animal("dog", "woof!");
dog.speak(); // the dog says woof!
```

---

# Classes 2: inheritance and static methods.

```javascript
class Dog extends Animal {
  constructor(name, breed) {
    super("dog", "woof!");
    this.name = name;
    this.breed = breed;
  }

  static makeDalmatian(name) {
    return new Dog(name, "Dalmatian")
  }
}

const dog = Dog.makeDalmation("Spot");
// calls new Dog("Spot", "Dalmatian");
```

---

# for/of loops

Standard: ES2015

```javascript
var array = ["James", "Amy", "Mike"];

for(var i = 0; i !== array.length; i++) {
  console.log(array[i]);
}
```

becomes

```javascript
const array = ["James", "Amy", "Mike"];

for(let name of array) {
  console.log(name);
}
```

---

# for/of loops 2

- Can be used to easily iterate over things other than arrays, such as function arguments

```javascript
function printAll() {
  var args = [].slice.call(arguments);
  for(var i = 0; i !== args.length; i++) {
    console.log(args[i]);
  }
}
```

becomes

```javascript
function printAll() {
  for(let arg of arguments) {
    console.log(arg);
  }
}

printAll(1,2,3);
// 1
// 2
// 3
```

- for/of is extensible: You can create your own iterable objects &amp; classes

---

# Generators

Standard: ES2015

Generators are functions which *yield* multiple values by pausing in their execution.

---

# Generators 2

```javascript
function* generator() {
  yield 1;
  yield 2;
  yield 3;
}

var g = generator();
console.log(g.next().value); // 1
console.log(g.next().value); // 2
console.log(g.next().value); // 3
```

---

# Generators 3

Generators often yield the result of loops

For example, an even number generator

``` javascript
function* evens(n) {
  for(let i = 0; i <= n; i += 2) {
    yield i;
  }
}

var g = evens(6); // Generate even numbers up to 6
console.log(g.next().value); // 0
console.log(g.next().value); // 2
console.log(g.next().value); // 4
console.log(g.next().value); // 6
```

---

# for/of loops 3: custom generator

```javascript
function* range(n, step) {
  for(let i = 0; i <= n; i += step) {
    yield i;
  }
}

for(let i of range(10, 2)) {
  console.log(i);
}
// 0 2 4 6 8 10
```

---

# Arrow functions

Shorter than writing functions

```javascript
function add(a, b) {
  return a + b;
}
```

```javascript
// No braces or return needed if returning an expression
const add = (a, b) => a + b;

// You can use braces + return as well if you need to do something more complex
const add = (a, b) => {
  return a + b;
}

// No parentheses needed for single-argument functions
const add2 = a => a + 2
```

---

# Arrow functions 2

The important thing is that arrow functions have different binding rules.

```javascript
// Repeats message every second
this.message = "Hello";

setInterval(function() {
  // Because `this` will be changed when this function is executed, 
  // this will print "undefined" repeatedly
  console.log(this.message);
}, 1000)
```

---

# Arrow functions 3

Old solution

```javascript
this.message = "message";

// Create a closure with a variable referencing the object we want to use
var self = this;
setInterval(function() {
  console.log(self.message);
}, 1000)
```

---

# Arrow functions 4

Arrow functions inherit `this` and `arguments` from the context they are written in

```javascript
this.message = "message";

setInterval(() => {
  // No additional code required to reference 'this'
  console.log(this.message);
}, 1000);
```

Very handy when working with classes, e.g. React components

---

# Default function arguments

```javascript
function raiseToPower(number, exponent = 2) {
  return Math.pow(number, exponent);
}

console.log(raiseToPower(4)); // 4^2 = 16
console.log(raiseToPower(4, 3)); // 4^3 = 64
```

---

# Template literals 1

lots of javascript code uses string concatenation

```javascript
let person = {
  name: "James",
  age: 24
};

console.log("Name: '" + person.name + "', age: " + person.age); 
// Name: 'James', age: 24
```

---

# Template literals 2

Uses backticks

```javascript
let person = {
  name: "James",
  age: 24
}

console.log(`Name: '${person.name}', age: ${person.age}`);
// Name: 'James', age: 24
```

---

# Template literals 3

You can write custom template literals that turn strings into any kind of value you want.

For example, a CSS color parser that breaks down a string like '#ff0000' into an array like [255, 0, 0]

```javascript
function color(strings) {
  const string = strings[0];
  return [
    parseInt(string.slice(1, 3), 16),
    parseInt(string.slice(3, 5), 16),
    parseInt(string.slice(5, 7), 16)
  ];
}

const red = color`#ff0000`;
console.log(red); // [255, 0, 0]
```

---

# Template literals 4

These can become quite elaborate

For example: hyperx is a library that allows you to build HTML from a string

```javascript
function click() {
  alert("Button was clicked");
}

var button = hx`<button onclick=${click}>Click me!</button>`
console.log(button); // <button></button>
```

---

# Object property shorthand

```javascript
var name = "James", age = 24, occupation = "Electrician";

var person = {
  name: name,
  age: age,
  occupation: occupation
}
```

### becomes

```javascript
let name = "James", age = 24, occupation = "Electrician";

// Variable names without a colon are automatically used as property names
let person = {name, age, occupation};
```

---

# Object property shorthand 2

Methods

```javascript

let person = {
  name: "James",
  age: 24,
  toString() {
    return `Name: ${this.name}, age: ${this.age}`;
  }
}

console.log(person.toString()); // Name: James, age: 24
```

---

# Destructuring bind

``` javascript
var color = [255, 0, 0];
var red = color[0];
var green = color[1];
var blue = color[2];
```

### becomes

```javascript
const color = [255, 0, 0];
const [red, green, blue] = color;
```

---

# Destructuring bind 2

also works on objects

```javascript
var person = {
  name: "James",
  age: 24, 
  occupation: "Electrician"
}

var name = person.name;
var age = person.age;
var occupation = person.occupation;
```

### becomes

```javascript
const person = {
  name: "James",
  age: 24,
  occupation: "Electrician"
};

const {name, age, occupation} = person;
```

---

# Destructuring bind 3

Can be nested arbitrarily

```javascript
const person = {
  name: "James", 
  age: 24,
  occupations: ["Electrician", "Plumber"]
};

const {name, age, occupations: [occupation1, occupation2]} = person;

console.log(name, age, occupation1, occupation2);
// James 24 Electrician Plumber
```

---

# Destructuring bind 4

Can even be used in function parameters

```javascript
function printPerson({name, age}) {
  console.log(name, age);
}

printPerson({name: "James", age: 24});
// James 24 
```

---

# Computed property names

Standard: ES2015

```javascript
var field = "spouse";

var person = {
  name: "James",
  age: 24
}

person[field] = "Mary";
```

## becomes

```javascript
const field = "spouse";
const person = {
  name: "James",
  age: 24,
  [field]: "Mary"
}
```

---

# Computed object properties 2

Computed object properties can be any valid expression

```javascript
var year = 2015;

const person = {
  name: "James",
  age: 24,
  [`salary${year}`]: 50000
}

console.log(person['salary2015']); // 50000
```

---

# Object.assign

Standard: ES2015

Copy and merge objects

```javascript
var person = { name: "James", age: 24}

Object.assign(person, { age: 25 });
```

Compare jQuery

```javascript
var person = { name: "James ", age: 24}

$.extend(person, { age: 25 })
```

---

# Object.assign 2

Also handy for copying objects

```javascript
var person = { name: "James", age: 24 };

var person2 = Object.assign({}, person);

person2.name = "Nathan";

console.log(person); // { name: "James", age: 24 }
console.log(person2); // { name: "Nathan", age: 24 }
```

---

# Rest parameters

Standard: ES2015

Can be used in function arguments, for example a function with variable arguments

```javascript
function sum() {
  var numbers = [].slice.call(arguments);
  
  return numbers.reduce(function(a, b) { return a + b });
}

sum(2,3,4); // 2 + 3 + 4 => 9
```

becomes

```javascript
function sum(...numbers) {
  return numbers.reduce((a, b) => a + b);
}
```

---

# Spread operator

Can also be used in reverse, to apply a function against multiple parameters

```javascript
console.log(...[1, 2, 3])

// equivalent to console.log(1, 2, 3);
```

And combined with destructuring bind

```javascript
const [first, ...rest] = [1, 2, 3, 4, 5];

console.log(first, rest); // 1, [2, 3, 4, 5]

```

---

# Spread operator 2: property spread

Not in any standard yet, just a proposal

Can be used to copy and modify objects

```javascript
var person = {name: "James", age: 24}
var person2 = {...person, age: 25}
// Equivalent to Object.assign({}, person, { age: 25 });
```

Really helps with Redux.

---

# Promises 1

```javascript
step1(function (value1) {
    step2(value1, function(value2) {
      // Do something with value2
    });
});
```

---

# Promises 2

```javascript
step1()
  .then(value1 => step2(value1))
  .done(value2 => {
    // Do something with value 2
  }).catch(() => {
    // Catch errors at any point during this

  });
```

---

# Async/await

Standard: ES2017

```javascript

async () =>
  const value1 = await step1();
  const value2 = await step2(value1);
  console.log(value2);
```

---

# Modules

#### globals

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"></script>
```

---

# commonjs

```javascript
var $ = require("jquery");
var bootstrap = require("bootstrap");

module.exports = {
  myFunction: function() {},
  myVariable: true,
  // ....
}
```
---

# es2015 modules

```javascript
import $ from 'jquery';
import bootstrap from 'bootstrap';

export function myFunction() {

}

export const myVariable = true;
```

---

# es2015 modules 2

ES2015 modules are static, and imports cannot be changed at runtime.

```javascript
import $ from 'jquery';

$ = somethingElse; // error!
```

This allows an intelligent bundler to eliminate dead code. ("tree-shaking")

---

# Selectors API

Find HTML elements by class, ID, element type, etc

Heavily inspired by jQuery

Compare
```javascript
$("div.myClass") // select <div class="myClass"></div>
```

```javascript
document.querySelector("div.myClass");
```

---

# window.fetch

Old style, pretty awkward

```javascript
var req = new XMLHttpRequest();
req.addEventListener("load", onLoad);
req.open('GET', 'https://example.com/example.json');
req.send();
```

Or jQuery

```javascript
$.get('https://example.com/example.json', function(response) {

});
```

---

# window.fetch 2

Standard: WHATWG Living Standard

Built into browser, based on Promises

```javascript
window.fetch('https://example.com/example.json')
  .then(response => response.json())
  .then(result => {

  });
```

---

# JSX

- mix HTML or other XML-like formats with JavaScript code
- not a proposed part of any standard
- used by react, react native, and other web frameworks

```
const message = "Hello world";
const element = <div>
  <p style={{color: 'green'}}>{message}</p>
</div>
```

transpiles down to

```javascript
var message = "Hello world";
var element = React.createElement(
  "div",
  null,
  React.createElement(
    "p",
    { style: { color: 'green' } },
    message
  )
);
```

---

# Problem

Browser support is highly variable

---

# Solution: transpilation

- Support new language features by compiling new down to older standards
- However, generally doesn't handle runtime functionality such as Object.assign, document.querySelector, etc

---

# Solution: polyfills

- A small bit of code that checks whether a feature is supported in a browser
- If not, will load more code and extend the environment with new functionality

---

# Babel

- from Facebook

- very extensible, supports multiple standards as well as plugins to add new features such as JSX
and spread operator

```javascript
const name = "James";
const age = 24;

const person = {name, age};

console.log(`Name: ${person.name}, age: ${person.age}`);
```

compiles down to

```javascript
var name = "James";
var age = 24;

var person = { name: name, age: age };

console.log("Name: " + person.name + ", age: " + person.age);
```

---

# Webpack

- Handles running various preprocessors, bundling and compressing resulting code and static
resources
- Not required for compatibility, but useful to handle a complex build process
- In combination with ES2015 modules, can remove unused code

???

stop here for livecoding

---

# ESLint + AirBNB style guide

---
    </textarea>
    <script src="remark-latest.min.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        var slideshow = remark.create();
      });
    </script>
  </body>
</html>
